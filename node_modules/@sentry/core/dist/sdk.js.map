{"version":3,"file":"sdk.js","sourceRoot":"","sources":["../src/sdk.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,mCAA4C;AAG5C,mCAAkC;AAOlC;;;;;;;GAOG;AACH,SAAgB,WAAW,CACzB,WAA8B,EAC9B,OAAU,EACV,mBAAuC;IAAvC,oCAAA,EAAA,wBAAuC;IAEvC,IAAI,OAAO,CAAC,KAAK,EAAE;QACjB,eAAM,CAAC,MAAM,EAAE,CAAC;KACjB;IAED,IAAI,mBAAa,EAAE,CAAC,SAAS,EAAE,EAAE;QAC/B,OAAO;KACR;IAED,IAAM,MAAM,GAAG,IAAI,WAAW,CAAC,OAAO,CAAC,CAAC;IACxC,MAAM,CAAC,OAAO,EAAE,CAAC;IAEjB,gFAAgF;IAChF,iDAAiD;IACjD,mBAAa,EAAE,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAEnC,IAAI,YAAY,GAAG,OAAO,CAAC,mBAAmB,KAAK,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,UAAK,mBAAmB,CAAC,CAAC;IACzF,IAAI,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;QACvC,IAAM,2BAAyB,GAAG,OAAO,CAAC,YAAY,CAAC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAA,CAAC,CAAC,IAAI,EAAN,CAAM,CAAC,CAAC;QACxE,YAAY,YAEP,YAAY,CAAC,MAAM,CAAC,UAAA,WAAW,IAAI,OAAA,2BAAyB,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAA1D,CAA0D,CAAC,EAC9F,OAAO,CAAC,YAAY,CACxB,CAAC;KACH;SAAM,IAAI,OAAO,OAAO,CAAC,YAAY,KAAK,UAAU,EAAE;QACrD,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC,YAAY,CAAC,CAAC;KACnD;IAED,2EAA2E;IAC3E,IAAI,KAAK,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;QAC/B,YAAY,CAAC,OAAO,CAAC,UAAA,WAAW;YAC9B,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAC7B,eAAM,CAAC,GAAG,CAAC,4BAA0B,WAAW,CAAC,IAAM,CAAC,CAAC;QAC3D,CAAC,CAAC,CAAC;KACJ;AACH,CAAC;AAvCD,kCAuCC","sourcesContent":["import { getCurrentHub } from '@sentry/hub';\nimport { Integration } from '@sentry/types';\nimport { Client, Options } from './interfaces';\nimport { logger } from './logger';\n\n/** A class object that can instanciate Client objects. */\nexport interface ClientClass<F extends Client, O extends Options> {\n  new (options: O): F;\n}\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instanciate.\n * @param options Options to pass to the client.\n * @returns The installed and bound client instance.\n */\nexport function initAndBind<F extends Client, O extends Options>(\n  clientClass: ClientClass<F, O>,\n  options: O,\n  defaultIntegrations: Integration[] = [],\n): void {\n  if (options.debug) {\n    logger.enable();\n  }\n\n  if (getCurrentHub().getClient()) {\n    return;\n  }\n\n  const client = new clientClass(options);\n  client.install();\n\n  // This should happen here if any integration uses {@link Hub.addEventProcessor}\n  // there needs to be a client on the hub already.\n  getCurrentHub().bindClient(client);\n\n  let integrations = options.defaultIntegrations === false ? [] : [...defaultIntegrations];\n  if (Array.isArray(options.integrations)) {\n    const providedIntegrationsNames = options.integrations.map(i => i.name);\n    integrations = [\n      // Leave only unique integrations, that were not overridden with provided integrations with the same name\n      ...integrations.filter(integration => providedIntegrationsNames.indexOf(integration.name) === -1),\n      ...options.integrations,\n    ];\n  } else if (typeof options.integrations === 'function') {\n    integrations = options.integrations(integrations);\n  }\n\n  // Just in case someone will return non-array from a `itegrations` callback\n  if (Array.isArray(integrations)) {\n    integrations.forEach(integration => {\n      integration.install(options);\n      logger.log(`Integration installed: ${integration.name}`);\n    });\n  }\n}\n"]}