{"version":3,"file":"baseclient.js","sourceRoot":"","sources":["../src/baseclient.ts"],"names":[],"mappings":"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","sourcesContent":["import { Scope } from '@sentry/hub';\nimport {\n  Breadcrumb,\n  SentryBreadcrumbHint,\n  SentryEvent,\n  SentryEventHint,\n  SentryResponse,\n  SentryWrappedFunction,\n  Severity,\n  Status,\n} from '@sentry/types';\nimport { forget } from '@sentry/utils/async';\nimport { getGlobalObject, uuid4 } from '@sentry/utils/misc';\nimport { truncate } from '@sentry/utils/string';\nimport { BackendClass } from './basebackend';\nimport { Dsn } from './dsn';\nimport { Backend, Client, Options } from './interfaces';\n\n/** JSDoc */\ninterface ExtensibleConsole extends Console {\n  [key: string]: any;\n}\n\n/** JSDoc */\nasync function beforeBreadcrumbConsoleLoopGuard(\n  callback: () => Breadcrumb | Promise<Breadcrumb | null> | null,\n): Promise<Breadcrumb | null> {\n  const global = getGlobalObject() as Window;\n  const levels = ['debug', 'info', 'warn', 'error', 'log'];\n\n  if (!('console' in global)) {\n    return callback();\n  }\n\n  const originalConsole = global.console as ExtensibleConsole;\n\n  // Restore all wrapped console methods\n  levels.forEach(level => {\n    if (level in global.console && (originalConsole[level] as SentryWrappedFunction).__sentry__) {\n      originalConsole[level] = (originalConsole[level] as SentryWrappedFunction).__sentry_original__;\n    }\n  });\n\n  // Perform callback manipulations\n  const result = await callback();\n\n  // Revert restoration to wrapped state\n  levels.forEach(level => {\n    if (level in global.console && (originalConsole[level] as SentryWrappedFunction).__sentry__) {\n      originalConsole[level] = (originalConsole[level] as SentryWrappedFunction).__sentry_wrapped__;\n    }\n  });\n\n  return result;\n}\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 30;\n\n/**\n * Absolute maximum number of breadcrumbs added to an event. The\n * `maxBreadcrumbs` option cannot be higher than this value.\n */\nconst MAX_BREADCRUMBS = 100;\n\n/**\n * By default, truncates URL values to 250 chars\n */\nconst MAX_URL_LENGTH = 250;\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the enviornment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  private readonly backend: B;\n\n  /** Options passed to the SDK. */\n  private readonly options: O;\n\n  /**\n   * The client Dsn, if specified in options. Without this Dsn, the SDK will be\n   * disabled.\n   */\n  private readonly dsn?: Dsn;\n\n  /**\n   * Stores whether installation has been performed and was successful. Before\n   * installing, this is undefined. Then it contains the success state.\n   */\n  private installed?: boolean;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this.backend = new backendClass(options);\n    this.options = options;\n\n    if (options.dsn) {\n      this.dsn = new Dsn(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public install(): boolean {\n    if (!this.isEnabled()) {\n      return (this.installed = false);\n    }\n\n    const backend = this.getBackend();\n    if (!this.installed && backend.install) {\n      backend.install();\n    }\n\n    return (this.installed = true);\n  }\n\n  /**\n   * Internal helper function to buffer promises.\n   *\n   * @param promise Any promise, but in this case Promise<SentryResponse>.\n   */\n  protected async buffer(promise: Promise<SentryResponse>): Promise<SentryResponse> {\n    return this.getBackend()\n      .getBuffer()\n      .add(promise);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureException(exception: any, hint?: SentryEventHint, scope?: Scope): Promise<SentryResponse> {\n    return this.buffer(\n      (async () => {\n        const event = await this.getBackend().eventFromException(exception, hint);\n        return this.captureEvent(event, hint, scope);\n      })(),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureMessage(\n    message: string,\n    level?: Severity,\n    hint?: SentryEventHint,\n    scope?: Scope,\n  ): Promise<SentryResponse> {\n    return this.buffer(\n      (async () => {\n        const event = await this.getBackend().eventFromMessage(message, level, hint);\n        return this.captureEvent(event, hint, scope);\n      })(),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureEvent(event: SentryEvent, hint?: SentryEventHint, scope?: Scope): Promise<SentryResponse> {\n    // Adding this here is technically not correct since if you call captureMessage/captureException it's already\n    // buffered. But since we not really need the count and we only need to know if the buffer is full or not,\n    // This is fine...\n    return this.buffer(\n      (async () =>\n        this.processEvent(event, async finalEvent => this.getBackend().sendEvent(finalEvent), hint, scope))(),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async addBreadcrumb(breadcrumb: Breadcrumb, hint?: SentryBreadcrumbHint, scope?: Scope): Promise<void> {\n    const { beforeBreadcrumb, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = this.getOptions();\n\n    if (maxBreadcrumbs <= 0) {\n      return;\n    }\n\n    const timestamp = new Date().getTime() / 1000;\n    const mergedBreadcrumb = { timestamp, ...breadcrumb };\n    const finalBreadcrumb = beforeBreadcrumb\n      ? await beforeBreadcrumbConsoleLoopGuard(() => beforeBreadcrumb(mergedBreadcrumb, hint))\n      : mergedBreadcrumb;\n\n    if (finalBreadcrumb === null) {\n      return;\n    }\n\n    if ((await this.getBackend().storeBreadcrumb(finalBreadcrumb)) && scope) {\n      scope.addBreadcrumb(finalBreadcrumb, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): Dsn | undefined {\n    return this.dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this.options;\n  }\n\n  /** Returns the current backend. */\n  protected getBackend(): B {\n    return this.backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this.dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional informartion about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected async prepareEvent(event: SentryEvent, scope?: Scope, hint?: SentryEventHint): Promise<SentryEvent | null> {\n    const { environment, maxBreadcrumbs = DEFAULT_BREADCRUMBS, release, repos, dist } = this.getOptions();\n\n    const prepared = { ...event };\n    if (prepared.environment === undefined && environment !== undefined) {\n      prepared.environment = environment;\n    }\n    if (prepared.release === undefined && release !== undefined) {\n      prepared.release = release;\n    }\n\n    if (prepared.repos === undefined && repos !== undefined) {\n      prepared.repos = repos;\n    }\n\n    if (prepared.dist === undefined && dist !== undefined) {\n      prepared.dist = dist;\n    }\n\n    if (prepared.message) {\n      prepared.message = truncate(prepared.message, MAX_URL_LENGTH);\n    }\n\n    const exception = prepared.exception && prepared.exception.values && prepared.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, MAX_URL_LENGTH);\n    }\n\n    const request = prepared.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, MAX_URL_LENGTH);\n    }\n\n    if (prepared.event_id === undefined) {\n      prepared.event_id = uuid4();\n    }\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (scope) {\n      return scope.applyToEvent(prepared, hint, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));\n    }\n\n    return prepared;\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   * The returned event status offers clues to whether the event was sent to\n   * Sentry and accepted there. If the {@link Options.shouldSend} hook returns\n   * `false`, the status will be {@link SendStatus.Skipped}. If the rate limit\n   * was exceeded, the status will be {@link SendStatus.RateLimit}.\n   *\n   * @param event The event to send to Sentry.\n   * @param send A function to actually send the event.\n   * @param scope A scope containing event metadata.\n   * @param hint May contain additional informartion about the original exception.\n   * @returns A Promise that resolves with the event status.\n   */\n  protected async processEvent(\n    event: SentryEvent,\n    send: (finalEvent: SentryEvent) => Promise<SentryResponse>,\n    hint?: SentryEventHint,\n    scope?: Scope,\n  ): Promise<SentryResponse> {\n    if (!this.isEnabled()) {\n      return {\n        status: Status.Skipped,\n      };\n    }\n\n    const { beforeSend, sampleRate } = this.getOptions();\n\n    if (typeof sampleRate === 'number' && sampleRate > Math.random()) {\n      return {\n        status: Status.Skipped,\n      };\n    }\n\n    const prepared = await this.prepareEvent(event, scope, hint);\n    if (prepared === null) {\n      return {\n        status: Status.Skipped,\n      };\n    }\n\n    let finalEvent: SentryEvent | null = prepared;\n\n    try {\n      const isInternalException = hint && hint.data && (hint.data as { [key: string]: any }).__sentry__ === true;\n      if (!isInternalException && beforeSend) {\n        finalEvent = await beforeSend(prepared, hint);\n      }\n    } catch (exception) {\n      forget(\n        this.captureException(exception, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: exception as Error,\n        }),\n      );\n\n      return {\n        reason: 'Event processing in beforeSend method threw an exception',\n        status: Status.Invalid,\n      };\n    }\n\n    if (finalEvent === null) {\n      return {\n        reason: 'Event dropped due to being discarded by beforeSend method',\n        status: Status.Skipped,\n      };\n    }\n\n    const response = await send(finalEvent);\n    response.event = finalEvent;\n\n    if (response.status === Status.RateLimit) {\n      // TODO: Handle rate limits and maintain a queue. For now, we require SDK\n      // implementors to override this method and handle it themselves.\n    }\n\n    return response;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async close(timeout?: number): Promise<boolean> {\n    return this.getBackend()\n      .getBuffer()\n      .drain(timeout);\n  }\n}\n"]}