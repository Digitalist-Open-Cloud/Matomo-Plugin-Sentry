{"version":3,"file":"backend.js","sourceRoot":"","sources":["../src/backend.ts"],"names":[],"mappings":"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","sourcesContent":["import { BaseBackend } from '@sentry/core';\nimport { Event, EventHint, Options, Severity, Transport } from '@sentry/types';\nimport { isDOMError, isDOMException, isError, isErrorEvent, isPlainObject } from '@sentry/utils/is';\nimport { addExceptionTypeValue } from '@sentry/utils/misc';\nimport { supportsFetch } from '@sentry/utils/supports';\nimport { SyncPromise } from '@sentry/utils/syncpromise';\n\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\nimport { FetchTransport, XHRTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Browser SDK.\n * @see BrowserClient for more information.\n */\nexport interface BrowserOptions extends Options {\n  /**\n   * A pattern for error URLs which should not be sent to Sentry.\n   * To whitelist certain errors instead, use {@link Options.whitelistUrls}.\n   * By default, all errors will be sent.\n   */\n  blacklistUrls?: Array<string | RegExp>;\n\n  /**\n   * A pattern for error URLs which should exclusively be sent to Sentry.\n   * This is the opposite of {@link Options.blacklistUrls}.\n   * By default, all errors will be sent.\n   */\n  whitelistUrls?: Array<string | RegExp>;\n}\n\n/**\n * The Sentry Browser SDK Backend.\n * @hidden\n */\nexport class BrowserBackend extends BaseBackend<BrowserOptions> {\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const transportOptions = this._options.transportOptions\n      ? this._options.transportOptions\n      : { dsn: this._options.dsn };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (supportsFetch()) {\n      return new FetchTransport(transportOptions);\n    }\n    return new XHRTransport(transportOptions);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromException(exception: any, hint?: EventHint): SyncPromise<Event> {\n    let event: Event;\n\n    if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n      // If it is an ErrorEvent with `error` property, extract it to get actual Error\n      const errorEvent = exception as ErrorEvent;\n      exception = errorEvent.error; // tslint:disable-line:no-parameter-reassignment\n      event = eventFromStacktrace(computeStackTrace(exception as Error));\n      return SyncPromise.resolve(this._buildEvent(event, hint));\n    }\n    if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n      // then we just extract the name and message, as they don't provide anything else\n      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n      const domException = exception as DOMException;\n      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      const message = domException.message ? `${name}: ${domException.message}` : name;\n\n      return this.eventFromMessage(message, Severity.Error, hint).then(messageEvent => {\n        addExceptionTypeValue(messageEvent, message);\n        return SyncPromise.resolve(this._buildEvent(messageEvent, hint));\n      });\n    }\n    if (isError(exception as Error)) {\n      // we have a real Error object, do nothing\n      event = eventFromStacktrace(computeStackTrace(exception as Error));\n      return SyncPromise.resolve(this._buildEvent(event, hint));\n    }\n    if (isPlainObject(exception as {}) && hint && hint.syntheticException) {\n      // If it is plain Object, serialize it manually and extract options\n      // This will allow us to group events based on top-level keys\n      // which is much better than creating new group when any key/value change\n      const objectException = exception as {};\n      event = eventFromPlainObject(objectException, hint.syntheticException);\n      addExceptionTypeValue(event, 'Custom Object', undefined, {\n        handled: true,\n        synthetic: true,\n        type: 'generic',\n      });\n      event.level = Severity.Error;\n      return SyncPromise.resolve(this._buildEvent(event, hint));\n    }\n\n    // If none of previous checks were valid, then it means that\n    // it's not a DOMError/DOMException\n    // it's not a plain Object\n    // it's not a valid ErrorEvent (one with an error property)\n    // it's not an Error\n    // So bail out and capture it as a simple message:\n    const stringException = exception as string;\n    return this.eventFromMessage(stringException, undefined, hint).then(messageEvent => {\n      addExceptionTypeValue(messageEvent, `${stringException}`, undefined, {\n        handled: true,\n        synthetic: true,\n        type: 'generic',\n      });\n      messageEvent.level = Severity.Error;\n      return SyncPromise.resolve(this._buildEvent(messageEvent, hint));\n    });\n  }\n\n  /**\n   * This is an internal helper function that creates an event.\n   */\n  private _buildEvent(event: Event, hint?: EventHint): Event {\n    return {\n      ...event,\n      event_id: hint && hint.event_id,\n    };\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): SyncPromise<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    if (this._options.attachStacktrace && hint && hint.syntheticException) {\n      const stacktrace = computeStackTrace(hint.syntheticException);\n      const frames = prepareFramesForEvent(stacktrace.stack);\n      event.stacktrace = {\n        frames,\n      };\n    }\n\n    return SyncPromise.resolve(event);\n  }\n}\n"]}